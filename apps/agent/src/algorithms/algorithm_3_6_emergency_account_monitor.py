"""Algorithm 3.6: Emergency Account Monitor.

Monitors emergency/break-glass accounts for inappropriate usage, ensures
proper audit trails, and detects potential abuse.

Business Value:
  - Compliance: SOX requires emergency account monitoring
  - Security: Detect stolen emergency credentials
  - Audit: Evidence for emergency access reviews
  - Risk Management: Limit inappropriate usage

Severity Levels:
  - CRITICAL: Unapproved access, out-of-scope activities, high-risk actions
    without authorization
  - HIGH: Session duration exceeds 2x expected
  - MEDIUM: Access outside authorized time window, justification mismatch

See Requirements/07-Advanced-Algorithms-Expansion.md, Algorithm 3.6
(lines 751-916).

Author: D365 FO License Agent
Created: 2026-02-06
"""

from __future__ import annotations

from datetime import datetime
from typing import Any, List

import pandas as pd
from pydantic import BaseModel, Field


# ---------------------------------------------------------------------------
# High-risk menu items (per specification)
# ---------------------------------------------------------------------------

HIGH_RISK_MENU_ITEMS: frozenset[str] = frozenset(
    {
        "BankReconciliation",
        "GeneralJournalPost",
        "VendorPayment",
    }
)

# ---------------------------------------------------------------------------
# Pydantic models
# ---------------------------------------------------------------------------


class EmergencyAccountConfig(BaseModel):
    """Configuration for a single emergency/break-glass account.

    Attributes:
        account_id: Unique identifier for the emergency account.
        account_name: Human-readable account name.
        account_type: Type of emergency account (break-glass, emergency).
        authorized_approvers: List of manager IDs who can approve usage.
        max_session_hours: Maximum allowed session duration in hours.
    """

    account_id: str = Field(description="Unique emergency account identifier")
    account_name: str = Field(
        default="Emergency Admin",
        description="Human-readable account name",
    )
    account_type: str = Field(
        default="break-glass",
        description="Type: break-glass or emergency",
    )
    authorized_approvers: List[str] = Field(
        default_factory=list,
        description="Manager IDs authorized to approve usage",
    )
    max_session_hours: int = Field(
        default=4,
        description="Maximum session duration in hours",
    )


class EmergencyAccountAlert(BaseModel):
    """Alert generated by emergency account monitoring.

    Attributes:
        account_id: The emergency account that triggered the alert.
        severity: CRITICAL, HIGH, MEDIUM, or LOW.
        issue: Description of the detected issue.
        recommendation: Recommended action to take.
        out_of_scope_count: Number of out-of-scope activities detected.
    """

    account_id: str = Field(description="Emergency account identifier")
    severity: str = Field(description="Alert severity: CRITICAL/HIGH/MEDIUM/LOW")
    issue: str = Field(description="Description of detected issue")
    recommendation: str = Field(description="Recommended remediation action")
    out_of_scope_count: int = Field(
        default=0,
        description="Number of activities performed outside approved scope",
    )


class EmergencyAccountAnalysis(BaseModel):
    """Aggregated result of emergency account monitoring.

    Attributes:
        algorithm_id: Always '3.6'.
        alerts: List of generated alerts.
        total_sessions_analyzed: Number of emergency sessions analyzed.
        total_emergency_accounts_monitored: Number of accounts monitored.
    """

    algorithm_id: str = Field(
        default="3.6",
        description="Algorithm identifier",
    )
    alerts: List[EmergencyAccountAlert] = Field(
        default_factory=list,
        description="Generated alerts",
    )
    total_sessions_analyzed: int = Field(
        default=0,
        description="Total emergency sessions analyzed",
    )
    total_emergency_accounts_monitored: int = Field(
        default=0,
        description="Number of emergency accounts monitored",
    )


# ---------------------------------------------------------------------------
# Severity ranking (higher index = higher severity)
# ---------------------------------------------------------------------------

_SEVERITY_RANK: dict[str, int] = {
    "LOW": 0,
    "MEDIUM": 1,
    "HIGH": 2,
    "CRITICAL": 3,
}


def _max_severity(a: str, b: str) -> str:
    """Return the higher of two severity levels."""
    return a if _SEVERITY_RANK.get(a, 0) >= _SEVERITY_RANK.get(b, 0) else b


# ---------------------------------------------------------------------------
# Core analysis helpers
# ---------------------------------------------------------------------------


def _parse_ts(value: str) -> datetime:
    """Parse a timestamp string to datetime."""
    return datetime.strptime(value, "%Y-%m-%d %H:%M:%S")


def _check_unapproved_access(
    account_id: str,
) -> EmergencyAccountAlert:
    """Generate CRITICAL alert for unapproved emergency access."""
    return EmergencyAccountAlert(
        account_id=account_id,
        severity="CRITICAL",
        issue="Emergency account used without approval",
        recommendation=(
            "IMMEDIATE: Investigate unauthorized emergency account access"
        ),
    )


def _check_out_of_scope(
    account_id: str,
    actual_menu_items: set[str],
    authorized_activities: list[str],
) -> EmergencyAccountAlert | None:
    """Check for activities outside the approved scope.

    Returns CRITICAL alert if any menu items are outside scope, else None.
    """
    authorized_set = set(authorized_activities)
    outside = actual_menu_items - authorized_set

    if not outside:
        return None

    return EmergencyAccountAlert(
        account_id=account_id,
        severity="CRITICAL",
        issue=(
            f"Activities outside approved scope: "
            f"{len(outside)} unauthorized menu items accessed"
        ),
        recommendation=(
            "IMMEDIATE: Investigate out-of-scope activities and revoke "
            "access if abuse confirmed"
        ),
        out_of_scope_count=len(outside),
    )


def _check_high_risk_actions(
    account_id: str,
    actual_menu_items: set[str],
    includes_high_risk: bool,
) -> EmergencyAccountAlert | None:
    """Check for high-risk actions without explicit authorization.

    Returns CRITICAL alert if high-risk menu items used without auth, else None.
    """
    high_risk_used = actual_menu_items & HIGH_RISK_MENU_ITEMS

    if not high_risk_used or includes_high_risk:
        return None

    return EmergencyAccountAlert(
        account_id=account_id,
        severity="CRITICAL",
        issue=(
            f"High-risk actions performed without authorization: "
            f"{', '.join(sorted(high_risk_used))}"
        ),
        recommendation=(
            "IMMEDIATE: Investigate unauthorized high-risk financial "
            "actions and assess potential impact"
        ),
    )


def _check_duration_exceeded(
    account_id: str,
    session_start: datetime,
    session_end: datetime,
    expected_duration_hours: float,
) -> EmergencyAccountAlert | None:
    """Check if session duration exceeds 2x expected.

    Returns HIGH alert if duration > 2x expected, else None.
    """
    actual_hours = (session_end - session_start).total_seconds() / 3600.0

    if actual_hours <= expected_duration_hours * 2:
        return None

    return EmergencyAccountAlert(
        account_id=account_id,
        severity="HIGH",
        issue=(
            f"Session duration exceeded: {actual_hours:.1f}h actual vs "
            f"{expected_duration_hours}h expected (>{2 * expected_duration_hours}h threshold)"
        ),
        recommendation=(
            "Investigate extended emergency session and review all "
            "activities performed after expected end time"
        ),
    )


def _check_time_window(
    account_id: str,
    activity_timestamps: list[datetime],
    authorized_start: datetime,
    authorized_end: datetime,
) -> EmergencyAccountAlert | None:
    """Check for activity outside the authorized time window.

    Returns MEDIUM alert if any activity falls outside the window, else None.
    """
    outside_count = sum(
        1 for ts in activity_timestamps
        if ts < authorized_start or ts > authorized_end
    )

    if outside_count == 0:
        return None

    return EmergencyAccountAlert(
        account_id=account_id,
        severity="MEDIUM",
        issue=(
            f"Access outside authorized time window: "
            f"{outside_count} activities outside "
            f"{authorized_start.strftime('%H:%M')}-"
            f"{authorized_end.strftime('%H:%M')}"
        ),
        recommendation=(
            "Review emergency account access timing and verify "
            "activities outside window were justified"
        ),
    )


def _check_justification_mismatch(
    account_id: str,
    justification: str,
    actions: list[str],
) -> EmergencyAccountAlert | None:
    """Check if justification does not match activity pattern.

    Per spec: if justification contains 'system outage' but >80% of
    activities are read-only, this is a MEDIUM severity mismatch.

    Returns MEDIUM alert if mismatch detected, else None.
    """
    if "system outage" not in justification.lower():
        return None

    if not actions:
        return None

    read_count = sum(1 for a in actions if a.lower() == "read")
    read_ratio = read_count / len(actions)

    if read_ratio <= 0.8:
        return None

    return EmergencyAccountAlert(
        account_id=account_id,
        severity="MEDIUM",
        issue=(
            f"Justification mismatch: claimed 'system outage' but "
            f"{read_ratio:.0%} of activities were read-only"
        ),
        recommendation=(
            "Review emergency access justification; read-only "
            "activity does not align with system outage claim"
        ),
    )


# ---------------------------------------------------------------------------
# Main entry point
# ---------------------------------------------------------------------------


def monitor_emergency_accounts(
    emergency_accounts: list[EmergencyAccountConfig],
    user_activity: pd.DataFrame,
    approval_records: pd.DataFrame,
) -> EmergencyAccountAnalysis:
    """Algorithm 3.6: Monitor emergency/break-glass accounts for abuse.

    Analyzes emergency account activity against approval records to detect:
      1. Unapproved access (CRITICAL)
      2. Activities outside approved scope (CRITICAL)
      3. High-risk actions without authorization (CRITICAL)
      4. Session duration exceeding 2x expected (HIGH)
      5. Access outside authorized time window (MEDIUM)
      6. Justification mismatch (MEDIUM)

    Args:
        emergency_accounts: Configured emergency accounts to monitor.
        user_activity: DataFrame with columns:
            user_id, timestamp, menu_item, action, session_id.
        approval_records: DataFrame with columns:
            approval_id, account_id, approver_id, approved_at,
            expected_duration_hours, authorized_activities,
            includes_high_risk, justification,
            authorized_time_start, authorized_time_end.

    Returns:
        EmergencyAccountAnalysis with alerts and summary statistics.

    See Requirements/07-Advanced-Algorithms-Expansion.md, Algorithm 3.6.
    """
    alerts: list[EmergencyAccountAlert] = []
    total_sessions = 0

    if not emergency_accounts:
        return EmergencyAccountAnalysis(
            algorithm_id="3.6",
            alerts=[],
            total_sessions_analyzed=0,
            total_emergency_accounts_monitored=0,
        )

    # Build set of monitored account IDs for fast lookup
    monitored_ids: set[str] = {acct.account_id for acct in emergency_accounts}

    # Filter activity to only emergency accounts
    if user_activity.empty:
        return EmergencyAccountAnalysis(
            algorithm_id="3.6",
            alerts=[],
            total_sessions_analyzed=0,
            total_emergency_accounts_monitored=len(emergency_accounts),
        )

    emergency_activity = user_activity[
        user_activity["user_id"].isin(monitored_ids)
    ]

    if emergency_activity.empty:
        return EmergencyAccountAnalysis(
            algorithm_id="3.6",
            alerts=[],
            total_sessions_analyzed=0,
            total_emergency_accounts_monitored=len(emergency_accounts),
        )

    # Build approval lookup: account_id -> list of approval records
    approval_lookup: dict[str, list[dict[str, Any]]] = {}
    if not approval_records.empty:
        for _, row in approval_records.iterrows():
            acct_id = str(row["account_id"])
            if acct_id not in approval_lookup:
                approval_lookup[acct_id] = []
            row_dict: dict[str, Any] = {
                str(k): v for k, v in row.to_dict().items()
            }
            approval_lookup[acct_id].append(row_dict)

    # Process each emergency account
    for account in emergency_accounts:
        acct_activity = emergency_activity[
            emergency_activity["user_id"] == account.account_id
        ]
        if acct_activity.empty:
            continue

        # Count this as a session (grouped by account for simplicity)
        total_sessions += 1

        # Get approval records for this account
        account_approvals = approval_lookup.get(account.account_id, [])

        if not account_approvals:
            # No approval at all -- CRITICAL
            alerts.append(_check_unapproved_access(account.account_id))
            continue

        # Use the most recent / first approval record for checks
        approval = account_approvals[0]

        # Gather activity data for checks
        actual_menu_items: set[str] = set(acct_activity["menu_item"].unique())
        actions: list[str] = list(acct_activity["action"])
        timestamps: list[datetime] = [
            _parse_ts(str(ts)) for ts in acct_activity["timestamp"]
        ]

        session_start = min(timestamps)
        session_end = max(timestamps)

        # Authorized activities
        authorized_activities: list[str] = approval.get(
            "authorized_activities", []
        )  # type: ignore[assignment]
        if isinstance(authorized_activities, str):
            authorized_activities = [authorized_activities]

        includes_high_risk: bool = bool(
            approval.get("includes_high_risk", False)
        )
        raw_duration: Any = approval.get("expected_duration_hours", 4)
        expected_duration: float = float(raw_duration)
        justification: str = str(approval.get("justification", ""))

        authorized_start = _parse_ts(
            str(approval.get("authorized_time_start", "2026-01-01 00:00:00"))
        )
        authorized_end = _parse_ts(
            str(approval.get("authorized_time_end", "2026-12-31 23:59:59"))
        )

        # Check 1: Out-of-scope activities (CRITICAL)
        scope_alert = _check_out_of_scope(
            account.account_id, actual_menu_items, authorized_activities
        )
        if scope_alert is not None:
            alerts.append(scope_alert)

        # Check 2: High-risk actions without authorization (CRITICAL)
        high_risk_alert = _check_high_risk_actions(
            account.account_id, actual_menu_items, includes_high_risk
        )
        if high_risk_alert is not None:
            alerts.append(high_risk_alert)

        # Check 3: Duration exceeded (HIGH)
        duration_alert = _check_duration_exceeded(
            account.account_id, session_start, session_end, expected_duration
        )
        if duration_alert is not None:
            alerts.append(duration_alert)

        # Check 4: Time window violation (MEDIUM)
        time_alert = _check_time_window(
            account.account_id, timestamps, authorized_start, authorized_end
        )
        if time_alert is not None:
            alerts.append(time_alert)

        # Check 5: Justification mismatch (MEDIUM)
        mismatch_alert = _check_justification_mismatch(
            account.account_id, justification, actions
        )
        if mismatch_alert is not None:
            alerts.append(mismatch_alert)

    return EmergencyAccountAnalysis(
        algorithm_id="3.6",
        alerts=alerts,
        total_sessions_analyzed=total_sessions,
        total_emergency_accounts_monitored=len(emergency_accounts),
    )
